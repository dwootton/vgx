<!DOCTYPE html>
<html>

<head>
  <title>ALX Chart Examples</title>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-hierarchy@3.1.2/dist/d3-hierarchy.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
  <script src="alx.js"></script>
  <style>
    .vis-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      padding: 20px;
    }

    .chart {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
    }

    h2 {
      margin: 0 0 10px 0;
      font-family: sans-serif;
    }
  </style>
</head>

<body>
  <div class="vis-container">
    <!-- Added binding tree container -->
    <div class="chart" style="grid-column: 1 / -1">
      <h2>Binding Tree</h2>
      <div id="binding-tree"></div>
    </div>
    
    <!-- Existing chart containers remain unchanged -->
    <div class="chart">
      <h2>Scatterplot</h2>
      <div id="scatter"></div>
    </div>
    <div class="chart">
      <h2>Histogram</h2>
      <div id="hist"></div>
    </div>
    <div class="chart">
      <h2>Line Plot</h2>
      <div id="line"></div>
    </div>
    <div class="chart">
      <h2>Bar Chart</h2>
      <div id="bar"></div>
    </div>
    <div class="chart">
      <h2>Heatmap</h2>
      <div id="heat"></div>
    </div>
    <div class="chart">
      <h2>Pie</h2>
      <div id="pie"></div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      alx = alx.alx
     
      // Generate better sample data
      const scatterData = Array.from({ length: 50 }, () => ({
        x: Math.random() * 100,
        y: Math.random() * 100
      }));





      // Data for histogram - single array of values
      const histData = Array.from({ length: 200 }, () => ({
        value: Math.random() * 100 + Math.random() * 50 // Create some clustering
      }));

      // Time series data
      const timeSeriesData = Array.from({ length: 100 }, (_, i) => ({
        time: i,
        value: Math.sin(i * 0.1) * 10 + Math.random() * 5
      }));

      // Categorical data with meaningful groups
      const categories = ['A', 'B', 'C', 'D', 'E'];
      const barData = Array.from({ length: 100 }, () => {
        const category = categories[Math.floor(Math.random() * categories.length)];
        return {
          category: category,
          value: Math.random() * 50 + (categories.indexOf(category) * 10) // Make data meaningful
        };
      });

      // Heatmap data with clear patterns
      const heatmapData = [];
      for (let x of categories) {
        for (let y of ['P', 'Q', 'R', 'S', 'T']) {
          // Create a pattern where values increase with both x and y
          const baseValue =
            (categories.indexOf(x) * 20) +
            (['P', 'Q', 'R', 'S', 'T'].indexOf(y) * 15);

          // Add multiple entries per cell for aggregation
          for (let i = 0; i < 3; i++) {
            heatmapData.push({
              x: x,
              y: y,
              value: baseValue + Math.random() * 10
            });
          }
        }
      }

      // // Create visualizations
      // const scatter = alx.scatterplot({
      //   data: scatterData,
      //   x: 'x',
      //   y: 'y',
      //   width: 400,
      //   height: 300,
      //   bind: alx.circle({
      //     x: 20,
      //     y: 60,
      //     bind: alx.drag()
      //   })
      // })

      const hist = alx.histogram({
        data: histData,
        x: 'value',
        width: 400,
        height: 300,
        bind: alx.brush2({name:'brush'})
      })







      // const line = alx.lineplot({
      //   data: timeSeriesData,
      //   x: 'time',
      //   y: 'value',
      //   width: 400,
      //   height: 300
      // })

      // const bar = alx.barchart({
      //   data: barData,
      //   x: 'category',
      //   y: 'value',
      //   aggregate: 'mean',
      //   width: 400,
      //   height: 300,
      //   bind: alx.brush({name:'brush'})
      // })

      // const heat = alx.heatmap({
      //   data: heatmapData,
      //   x: 'x',
      //   y: 'y',
      //   color: 'value',
      //   width: 400,
      //   height: 300
      // })

      // const pie = alx.piechart({
      //   data: barData,
      //   categoryField: 'category'
      // }
      // )

      // New rendering function for binding tree
      async function renderBindingTree(processedGraph, elementId) {
        const { nodes, edges } = processedGraph;
        
        // Constants for styling
        const STYLES = {
          width: 800,
          height: 600,
          padding: 50,
          nodeRadius: 25,
          nodeFill: '#ffffff',
          nodeStroke: '#333333',
          nodeStrokeWidth: 2,
          linkStroke: '#999999',
          linkStrokeWidth: 1.5,
          fontSize: 12,
          tooltipBackground: 'rgba(255, 255, 255, 0.9)',
          tooltipBorder: '1px solid #ddd'
        };

        // Helper functions
        const createTooltip = () => {
          return d3.select(`#${elementId}`)
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0)
            .style("position", "absolute")
            .style("background-color", STYLES.tooltipBackground)
            .style("border", STYLES.tooltipBorder)
            .style("border-radius", "4px")
            .style("padding", "10px")
            .style("pointer-events", "none");
        };

        const showTooltip = (tooltip, content, event) => {
          tooltip.transition()
            .duration(200)
            .style("opacity", .9);
          
          tooltip.html(content)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
        };

        const hideTooltip = (tooltip) => {
          tooltip.transition()
            .duration(500)
            .style("opacity", 0);
        };

        // Setup SVG
        const svg = d3.select(`#${elementId}`)
          .append('svg')
          .attr('width', STYLES.width)
          .attr('height', STYLES.height);

        const g = svg.append('g')
          .attr('transform', `translate(${STYLES.padding},${STYLES.padding})`);

        // Create tooltips
        const nodeTooltip = createTooltip();
        const edgeTooltip = createTooltip();

        // Process data for tree
        const uniqueNodes = Array.from(new Set(nodes.map(n => n.id)))
          .map(id => nodes.find(n => n.id === id));

        // Create hierarchy
        const root = d3.hierarchy({
          id: 'node_3',
          children: uniqueNodes.filter(n => n.id !== 'node_3')
        });

        // Create tree layout
        const treeLayout = d3.tree()
          .size([
            STYLES.width - (2 * STYLES.padding),
            STYLES.height - (2 * STYLES.padding)
          ]);

        treeLayout(root);

        // Draw edges
        edges.forEach((edge, index) => {
          const source = root.descendants().find(n => n.data.id === edge.source.original);
          const target = root.descendants().find(n => n.data.id === edge.target.original);
          
          if (source && target) {
            // Ensure targets are drawn below sources
            const sourceY = source.y;
            const targetY = Math.max(source.y + 100, target.y);
            
            // Fan out edges by adding horizontal offset based on index
            const sourceX = source.x;
            const targetX = target.x;
            const controlPointOffset = 50 + (index * 20); // Increase offset for each edge
            
            // Create curved path using cubic bezier
            const path = `M ${sourceX} ${sourceY}
                         C ${sourceX} ${sourceY + controlPointOffset},
                           ${targetX} ${targetY - controlPointOffset},
                           ${targetX} ${targetY}`;
            
            g.append('path')
              .attr('class', 'link')
              .attr('d', path)
              .attr('stroke', STYLES.linkStroke)
              .attr('stroke-width', STYLES.linkStrokeWidth)
              .attr('fill', 'none')
              .on('mouseover', (event) => {
                const tooltipContent = `
                  <strong>From:</strong> ${edge.source.original}<br/>
                  <strong>To:</strong> ${edge.target.original}<br/>
                  <strong>Source Anchor:</strong> ${edge.anchors.source}<br/>
                  <strong>Target Anchor:</strong> ${edge.anchors.target}
                `;
                // Position tooltip above the path
                showTooltip(edgeTooltip, tooltipContent, event);
                edgeTooltip.style("top", (event.pageY - 100) + "px"); // Fixed position above
              })
              .on('mouseout', () => hideTooltip(edgeTooltip));
          }
        });

        // Draw nodes
        const nodes_g = g.selectAll('.node')
          .data(root.descendants())
          .enter()
          .append('g')
          .attr('class', 'node')
          .attr('transform', d => `translate(${d.x},${d.y})`);

        // Node circles
        nodes_g.append('circle')
          .attr('r', STYLES.nodeRadius)
          .attr('fill', STYLES.nodeFill)
          .attr('stroke', STYLES.nodeStroke)
          .attr('stroke-width', STYLES.nodeStrokeWidth)
          .on('mouseover', (event, d) => {
            const node = nodes.find(n => n.id === d.data.id);
            if (!node) return;
            
            const tooltipContent = `
              <strong>ID:</strong> ${node.id}<br/>
              <strong>Type:</strong> ${node.type}<br/>
              <strong>Merged ID:</strong> ${node.mergedId}<br/>
              <strong>Anchors:</strong><br/>
              ${node.anchors ? node.anchors.map(anchor => 
                `- ${anchor.anchorSchema.id}: ${anchor.anchorSchema.type}`
              ).join('<br/>') : 'No anchors'}
            `;
            showTooltip(nodeTooltip, tooltipContent, event);
          })
          .on('mouseout', () => hideTooltip(nodeTooltip));

        // Node labels
        nodes_g.append('text')
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .style('font-size', `${STYLES.fontSize}px`)
          .text(d => d.data.id);
      }

      // Modified renderChart function
      const renderChart = async (chart, elementId) => {
        const vegaLiteSpec = await chart.compile();
        const bindingManager = alx.bindingManager();
        const processedGraph = bindingManager.getProcessedGraph(chart.id);

        // Render Vega chart
        await vegaEmbed(`#${elementId}`, vegaLiteSpec, { renderer: 'svg' });
        
        // Render binding tree
        renderBindingTree(processedGraph, 'binding-tree');
      };

      // Existing render calls remain unchanged
      await Promise.all([
        // renderChart(scatter, 'scatter'),
         renderChart(hist, 'hist'),
        // renderChart(line, 'line'),
        // renderChart(bar, 'bar'),
        // renderChart(heat, 'heat'),
        // renderChart(pie, 'pie')
      ]);
    });
  </script>
</body>

</html>